#!/bin/bash

# TrivialRC
# The minimalistic RC system and process manager for containers and applications
# Copyright (c) 2016, 2017 by Oleksii Tsvietnov, me@vorakl.name
trc_version="1.1.0"

# --[ Environment variables ]--
# RC_DEBUG (true|false) [false]
#    Prints out all commands which are being executed
# RC_VERBOSE (true|false) [false]
#    Prints out service information
# RC_VERBOSE_EXTRA (true|false) [false]
#    Prints out additional service information
# RC_WAIT_POLICY (wait_all|wait_any|wait_forever) [wait_any]
#    - wait_all      quits after exiting the last command (back- or foreground)
#    - wait_any      quits after exiting any command (including zero commands)
#    - wait_forever  will be waiting forever after exiting all commands.
#                    Usefull in case of daemons which are detaching and exiting
#    - wait_err      quits after the first failed command

set +e # Do not exit on errors by default
[[ "${RC_DEBUG}" = "true" ]] && set -x # Turns on Debug mode if true

main() {
    check_ver_usage $1

    trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_main_exit || exit $?; exit ${_exitcode}' EXIT
    trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
    trap '_exitcode=$?; [[ "${RC_WAIT_POLICY}" = "wait_err" ]] && { debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}; }' ERR

    local _wait_bg_cmd _file _exitcode=0 _exitcode2=0

    export SELF_NAME=$(basename $0 .sh) # Self name for logging purpose
    export DIR_NAME=$(dirname $0)
    export MAINPID="${BASHPID}" # PID of the main process
    export EXIT_FLAG="/tmp/trc.${MAINPID}.exiting"
    : ${RC_WAIT_POLICY:=wait_any}; export RC_WAIT_POLICY 

    halt_cmds=()
    child_pids="" # Collects of child processes
    ns="main" # Name Space

    # Checks if there is an exit flag on startup
    if [[ -n "${EXIT_FLAG}" ]] && [[ -f ${EXIT_FLAG} ]]; then
        err "An exit flag ${EXIT_FLAG} exists! Exiting..."
    fi

    case "${RC_WAIT_POLICY}" in
        wait_all)  _wait_bg_cmd="command -p wait";;
        wait_any)  _wait_bg_cmd="command -p wait";;
        wait_err)  _wait_bg_cmd="command -p wait";;
        *)         _wait_bg_cmd=":";;
    esac

    log "The wait policy: ${RC_WAIT_POLICY}"

    debug "Looking for \`boot\` scripts and commands..."
    {
        # Reads commands from files to run before everything
        set -e # On errors exits regardless of RC_WAIT_POLICY
        for _file in $(ls ${DIR_NAME}/trc.boot.* ${DIR_NAME}/trc.d/boot.* 2>/dev/null || true); do
            log "Launching on the $(ns_long ${ns}): ${_file}"
            . ${_file}
        done

        # Checks for boot tasks in the command line
        while [[ "$1" = "-B" ]]; do
            shift

            log "Launching on the $(ns_long ${ns}): $1"
            eval "$1"

            shift
        done
        set +e
    }

    debug "Looking for \`halt\` commands..."
    # Collects commands for the `halt` stage from a command line
    while [[ "$1" = "-H" ]]; do
        shift
            halt_cmds[${#halt_cmds[*]}]="$1"
        shift
    done

    debug "Looking for \`async\` scripts and commands..."
    # Reads commands from files to run on the background (in parallel)
    for _file in $(ls ${DIR_NAME}/trc.bg.* ${DIR_NAME}/trc.async.* ${DIR_NAME}/trc.d/async.* 2>/dev/null || true); do
        { # supressing stderr for avoiding uncontrolled messages like "Terminated" or "Killed"
              (
#                set -e
                # Run this on any exit, catching the exitcode of the "main" command,
                # printing additional info and finishing up this sub-program with the right exitcode
                trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "${_file}"; exit ${_exitcode}' EXIT

                # In case of exit on errors (set -e) or by a signal, catch exitcode and exit with it, which
                # will lead to triggering an EXIT trap
                trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
                trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

                ns="async"
                log "Launching on the $(ns_long ${ns}): ${_file}"
                . ${_file}
              )& 
        } 2> /dev/null
        child_pids="${child_pids} $!"
    done

    # Checks for background tasks in the command line
    while [[ "$1" = "-D" ]]; do
        shift
        { # supressing stderr for avoiding uncontrolled messages like "Terminated" or "Killed"
              (
#                set -e
                trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "$1"; exit ${_exitcode}' EXIT
                trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
                trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

                ns="async"
                log "Launching on the $(ns_long ${ns}): $1"
                eval "$1"
              )& 
        } 2> /dev/null
        child_pids="${child_pids} $!"
        shift
    done

    debug "Looking for \`sync\` scripts and commands..." 
    # Checks for foreground tasks in files (sequentially)
    for _file in $(ls ${DIR_NAME}/trc.fg.* ${DIR_NAME}/trc.sync.* ${DIR_NAME}/trc.d/sync.* 2>/dev/null || true); do
        (
#            set -e
            trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "${_file}"; exit ${_exitcode}' EXIT
            trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

            ns="sync"
            log "Launching on the $(ns_long ${ns}): ${_file}"
            . ${_file}
        )
        # Catch the exitcode of a foreground sub-program
        _exitcode=$?
    done

    # Checks for foreground tasks in the command line
    while [[ "$1" = "-F" ]]; do
        shift
#        set +e
        (
#            set -e
            trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "$1"; exit ${_exitcode}' EXIT
            trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

            ns="sync"
            log "Launching on the $(ns_long ${ns}): $1"
            eval "$1"
        )
        _exitcode=$?
        shift
    done

    # Checks for a foreground task in the command line (one parameter with all commands)
    if [[ -n "$*" ]]; then
        (
            set -e
            trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "$@"; exit ${_exitcode}' EXIT
            trap '_exitcode=$?; debug "sig-trap (exitcode=$_exitcode)"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap (exitcode=$_exitcode)"; exit ${_exitcode}' ERR

            ns="sync"
            log "Launching on the $(ns_long ${ns}): $@"
            "$@"
        )
        # Catch the exitcode of a foreground sub-program
        _exitcode=$?
    fi

    # Wait for all background processes and exit with a status of the last one
    # or with 128+SIGNAL in case of getting a signal
    ${_wait_bg_cmd} ${child_pids}
    _exitcode2=$?

    if [ ${_exitcode2} -ne 0 ]; then
        _exitcode=${_exitcode2} # update exit code only if one of background processes has failed
    fi

    if [[ "${RC_WAIT_POLICY}" = "wait_forever" ]]; then
        infinite_loop
    fi

    return ${_exitcode}
}

say() {
    if [[ "${RC_VERBOSE}" = "true" ]]; then
        echo "$@"
    fi
}

log() {
    say "$(date '+%Y-%m-%d %H:%M:%S') ${SELF_NAME} [${ns}/${BASHPID}]: $@"
}

warn() {
    log "$@" >&2
}

err() {
    warn "$@"
    exit 1
}

debug() {
    if [[ "${RC_VERBOSE_EXTRA}" = "true" ]]; then
        log " - $@"
    fi
}

hook_main_exit() {
#    set +e # do not stop or any errors, we have to stop properly
#    trap '' ERR # disable ERR trap

    # Checks if there is an exit flag on exit
    if [[ -n "${EXIT_FLAG}" ]] && [[ -f ${EXIT_FLAG} ]]; then
        warn "The exit flag ${EXIT_FLAG} exists! I'm already exiting..."
        return 0
    fi

    # Creating an exit flag
    touch ${EXIT_FLAG} || warn "Cannot create ${EXIT_FLAG}"

    local _pid _cpids _file _cmd _exitcode3=0 _exitcode4=0 _term_timeout=5

    log "Trying to terminate sub-processes..."
    for _pid in ${child_pids}; do
        if ps -p ${_pid} &> /dev/null; then
            debug "terminating the child process <pid=${_pid}>"

            # Removes all unexpected sub-processes
            _cpids="$(pgrep -P ${_pid} -d,)"
            kill -TERM ${_pid} $(echo "${_cpids}" | tr ',' ' ') &> /dev/null

            while ps -p ${_pid},${_cpids} &> /dev/null && [[ ${_term_timeout} -gt 0 ]]
            do
                sleep 1
                : $((_term_timeout--))
            done

            if ps -p ${_pid},${_cpids} &>/dev/null; then
                kill -KILL ${_pid} $(echo "${_cpids}" | tr ',' ' ') &> /dev/null
            fi
        fi
    done
    # Removes all unexpected sub-processes
    pkill -KILL -P ${MAINPID} &> /dev/null

    # --- `halt`
    { 
        debug "Looking for \`halt\` scripts..."
        # Checks for shutdown tasks in files (sequentially)
        for _file in $(ls ${DIR_NAME}/trc.sd.* ${DIR_NAME}/trc.halt.* ${DIR_NAME}/trc.d/halt.* 2>/dev/null || true); do
            (
                set -e # Exit on errors in the sub-shell

                ns="halt"
                log "Running the shutdown script: ${_file}"
                . ${_file}
            )
            _exitcode3=$?
            [[ ${_exitcode3} -ne 0 ]] && _exitcode4=${_exitcode3}
            log "Exiting from the shutdown script (exitcode=${_exitcode4}): ${_file}"
        done

        # Runs shutdown tasks from the command line if any
        for _cmd in "${halt_cmds[@]}"; do
            (
                set -e # Exit on errors in the sub-shell

                ns="halt"
                log "Running the shutdown command: ${_cmd}"
                eval "${_cmd}"
            )
            _exitcode3=$?
            [[ ${_exitcode3} -ne 0 ]] && _exitcode4=${_exitcode3}
            log "Exiting from the shutdown command (exitcode=${_exitcode4}): ${_cmd}"
        done    
    }

    if [[ -n "${EXIT_FLAG}" ]] && [[ -f ${EXIT_FLAG} ]]; then
        rm -f ${EXIT_FLAG} || { _exitcode4=$?; warn "Cannot remove ${EXIT_FLAG}"; }
    fi

    log "Exited."

    return ${_exitcode4}
}

hook_sub_exit() {
    set +e # do not stop or errors anyway

    local _rc=$1 # Getting the exit code for a logging purpose only
    shift

    log "Exiting on the $(ns_long ${ns}) (exitcode=${_rc}): $@"

    if [[ "${RC_WAIT_POLICY}" = "wait_any" ]]; then 
        if [[ -n "${EXIT_FLAG}" ]] && [[ ! -f ${EXIT_FLAG} ]]; then
            # If exiting from a bg process and don't need to wait other processes, let's stop the main
            if ps -p ${MAINPID} &> /dev/null; then
                debug "terminating the main process <pid=${MAINPID}>"
                kill -TERM ${MAINPID} &> /dev/null
            fi
        fi
    fi
    # To prevent invoking error trap from error trap ;)
    # The correct exit code was taken before diving into this function
    return 0
}

infinite_loop() {
    log "Activated infinite loop! To stop, press <Ctrl+C> or send SIGTERM..."
    while true; do
        sleep 60
    done
}

ns_long() {
    local _ns

    case "$1" in
        fg|sync)  _ns="foreground";;
        bg|async) _ns="background";;
        sd|halt)  _ns="shutdown";;
        main)     _ns="boot";;
         *)       _ns="$1";;
    esac

    echo "${_ns}"
}

check_ver_usage() {
    case "$1" in
        -v|--version) print_version ;;
        -h|--help)    print_usage ;;
         *)       : ;;
    esac
}

print_usage() {
    local _self=$0
    echo "Usage: ${_self} [-B 'cmds' [...]] [-H 'cmds' [...]] [-D 'cmds' [...]] [-F 'cmds' [...]] [cmd [args]]"
    echo "Examples:"
    echo -e " $ ${_self} -B 'name=\$(id -un); echo booting...' -H 'echo halting...' -F 'echo Hello, \${name}!'"
    echo -e " $ RC_WAIT_POLICY=wait_all ${_self} -D 'echo Hello' -D 'sleep 2; echo World' echo waiting..."
    echo -e " $ RC_VERBOSE=true ${_self} -F 'echo -n \"Hello \"; echo World'"

    exit 0
}

print_version() {
    echo "$trc_version"

    exit 0
}

main "$@"
