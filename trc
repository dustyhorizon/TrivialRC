#!/bin/bash

# TrivialRC - The minimalistic RC system and process manager for containers
# Copyright (c) 2016,2017 by Oleksii Tsvietnov, me@vorakl.name
# Version: 1.1.0

# --[ Environment ]--
# RC_DEBUG (true|false) [false]
#    Prints out all commands which are being executed
# RC_VERBOSE (true|false) [false]
#    Prints out service information
# RC_WAIT_POLICY (wait_all|wait_any|wait_forever) [wait_any]
#    - wait_all      quit after exiting the last command (back- or foreground)
#    - wait_any      quit after exiting any of command (including zero commands)
#    - wait_forever  will be waiting forever after exiting all commands.
#                    Usefull in case of daemons which are detaching and exiting

set +e # Do not exit on errors by default
if [[ "$RC_DEBUG" = "true" ]]; then
    set -x # Turns on Debug mode if true
fi
: ${RC_WAIT_POLICY:=wait_any} # Sets default value for a wait policy

main() {
    trap '_exitcode=$?; hook_main_exit; debug "exit-trap ($_exitcode)"; exit $_exitcode' EXIT
    trap '_exitcode=$?; debug "sig-trap ($_exitcode)"; exit $_exitcode' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
    trap '_exitcode=$?; debug "err-trap ($_exitcode)"; exit $_exitcode' ERR

    export SELF_NAME=$(basename $0 .sh) # Self name for logging purpose
    export DIR_NAME=$(dirname $0)
    export MAINPID="$BASHPID" # PID of the main process
    export EXIT_FLAG="/tmp/trc.$MAINPID.exiting"
    childpid="" # Collecting child processes
    ns="main" # Name Space
    local _wait_bg_cmd _file _exitcode=0 _exitcode2=0

    # Checks if there is an exit flag on startup
    if [[ -n "${EXIT_FLAG}" ]] && [[ -f ${EXIT_FLAG} ]]; then
        err "An exit flag ${EXIT_FLAG} exists! Exiting..."
    fi

    case "$RC_WAIT_POLICY" in
        wait_all)  _wait_bg_cmd="command -p wait";;
        wait_any)  _wait_bg_cmd="command -p wait";;
        *)         _wait_bg_cmd=":";;
    esac

    log "The wait policy: $RC_WAIT_POLICY"


    # Reads commands from files to run before everything
    for _file in $(ls $DIR_NAME/trc.boot.* $DIR_NAME/trc.d/boot.* 2>/dev/null || true); do
        set -e

        log "Launching on the $(ns_long $ns): $_file"
        . $_file

        set +e
    done

    # Checks for boot tasks in the command line
    while [[ "$1" = "-B" ]]; do
        shift
        set -e

        log "Launching on the $(ns_long $ns): $1"
        eval "$1"

        set +e
        shift
    done

    # Reads commands from files to run on the background (in parallel)
    for _file in $(ls $DIR_NAME/trc.bg.* $DIR_NAME/trc.async.* $DIR_NAME/trc.d/async.* 2>/dev/null || true); do
        { # Supress all output for a background process 
          (
            set -e
            # Run this on any exit, catching the exitcode of the "main" command,
            # printing additional info and finishing up this sub-program with the right exitcode
            trap '_exitcode=$?; hook_sub_exit $_exitcode "$_file"; debug "exit-trap ($_exitcode)"; exit $_exitcode' EXIT

            # In case of exit on errors (set -e) or by a signal, catch exitcode and exit with it, which
            # will lead to triggering an EXIT trap
            trap '_exitcode=$?; debug "sig-trap ($_exitcode)"; exit $_exitcode' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap ($_exitcode)"; exit $_exitcode' ERR

            ns="async"
            log "Launching on the $(ns_long $ns): $_file"
            . $_file
          )& 
        } &>/dev/null
        childpid="${childpid} $!"
    done

    # Checks for background tasks in the command line
    while [[ "$1" = "-D" ]]; do
        shift
        { 
          (
            set -e
            trap '_exitcode=$?; hook_sub_exit $_exitcode "$1"; debug "exit-trap ($_exitcode)"; exit $_exitcode' EXIT
            trap '_exitcode=$?; debug "sig-trap ($_exitcode)"; exit $_exitcode' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap ($_exitcode)"; exit $_exitcode' ERR

            ns="async"
            log "Launching on the $(ns_long $ns): $1"
            eval "$1"
          )& 
        } &>/dev/null
        childpid="${childpid} $!"
        shift
    done

    # Checks for foreground tasks in the command line
    while [[ "$1" = "-F" ]]; do
        shift
        (
            set -e
            trap '_exitcode=$?; hook_sub_exit $_exitcode "$1"; debug "exit-trap ($_exitcode)"; exit $_exitcode' EXIT
            trap '_exitcode=$?; debug "sig-trap ($_exitcode)"; exit $_exitcode' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap ($_exitcode)"; exit $_exitcode' ERR

            ns="sync"
            log "Launching on the $(ns_long $ns): $1"
            eval "$1"
        )
        shift
        _exitcode=$?
    done

    # Checks for foreground tasks in files (sequentially)
    for _file in $(ls $DIR_NAME/trc.fg.* $DIR_NAME/trc.sync.* $DIR_NAME/trc.d/sync.* 2>/dev/null || true); do
        (
            set -e
            trap '_exitcode=$?; hook_sub_exit $_exitcode "$_file"; debug "exit-trap ($_exitcode)"; exit $_exitcode' EXIT
            trap '_exitcode=$?; debug "sig-trap ($_exitcode)"; exit $_exitcode' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap ($_exitcode)"; exit $_exitcode' ERR

            ns="sync"
            log "Launching on the $(ns_long $ns): $_file"
            . $_file
        )
        # Catch the exitcode of a foreground sub-program
        _exitcode=$?
    done

    # Checks for a foreground task in the command line (one parameter with all commands)
    if [[ -n "$*" ]]; then
        (
            set -e
            trap '_exitcode=$?; hook_sub_exit $_exitcode "$@"; debug "exit-trap ($_exitcode)"; exit $_exitcode' EXIT
            trap '_exitcode=$?; debug "sig-trap ($_exitcode)"; exit $_exitcode' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap ($_exitcode)"; exit $_exitcode' ERR

            ns="sync"
            log "Launching on the $(ns_long $ns): $@"
            "$@"
        )
        # Catch the exitcode of a foreground sub-program
        _exitcode=$?
    fi

    # Wait for all background processes and exit with a status of the last one
    # or with 128+SIGNAL in case of getting a signal
    $_wait_bg_cmd $childpid
    _exitcode2=$?

    if [ $_exitcode2 -ne 0 ]; then
        _exitcode=$_exitcode2 # update exit code only if one of background processes has failed
    fi

    if [[ "$RC_WAIT_POLICY" = "wait_forever" ]]; then
        infinite_loop
    fi

    return $_exitcode
}

print() {
    if [[ "$RC_VERBOSE" = "true" ]]; then
        echo -en "$@"
    fi
}

say() {
    print "$@\n"
}

logn() {
    print "$(date '+%Y-%m-%d %H:%M:%S') ${SELF_NAME} [$ns/$BASHPID]: $@"
}

log() {
    logn "$@\n"
}

warnn() {
    logn "$@" >&2
}

warn() {
    log "$@" >&2
}

err() {
    warn "$@"
    exit 1
}

debug() {
    if [[ "$RC_DEBUG" = "true" ]]; then
        log "$@"
    fi
}

hook_main_exit() {
    set +e # do not stop or errors anyway

    local _pid _file

    # Creating an exit flag
    touch ${EXIT_FLAG} || warn "Cannot create ${EXIT_FLAG}"

    log "Going down. Running shutdown scripts..."
    # Checks for shutdown tasks in files (sequentially)
    for _file in $(ls $DIR_NAME/trc.sd.* $DIR_NAME/trc.halt.* $DIR_NAME/trc.d/halt.* 2>/dev/null || true); do
        (
            ns="halt"
            set -e # Exit on errors in the sub-shell
            log "Running the shutdown script: $_file"
            . $_file
        )
    done

    log "Handling of termination..."
    for _pid in $childpid; do
        if ps -p $_pid &> /dev/null; then
            logn " - terminating the child <$_pid> "

            # Removes all unexpected sub-processes
            pkill -TERM -P $_pid &> /dev/null           
            term_timeout=5
            kill -TERM $_pid &> /dev/null

            while ps -p $_pid &>/dev/null && [[ ${term_timeout} -gt 0 ]]
            do
                print "."
                sleep 1
                : $((term_timeout--))
            done

            if  ps -p $_pid &>/dev/null; then
                pkill -KILL -P $_pid &> /dev/null
                kill -KILL $_pid &> /dev/null
                say "Killed"
            else
                say "Done"
            fi
        fi
    done
    # Removes all unexpected sub-processes
    pkill -KILL -P $MAINPID &> /dev/null

    if [[ -n "${EXIT_FLAG}" ]] && [[ -f ${EXIT_FLAG} ]]; then
        rm -f ${EXIT_FLAG} || warn "Cannot remove ${EXIT_FLAG}"
    fi

    log "Exited."

    # It's not needed to exit with a proper exit code here.
    # The programm will exit with correct exit code from EXIT trap of main()
}

hook_sub_exit() {
    set +e # do not stop or errors anyway

    local _rc=$1 # Getting the exit code for a logging purpose only
    shift

    log "Exiting on the $(ns_long $ns) ($_rc): $@"

    if [[ "$RC_WAIT_POLICY" = "wait_any" ]]; then 
        if [[ -n "${EXIT_FLAG}" ]] && [[ ! -f ${EXIT_FLAG} ]]; then
            # If exiting from a bg process and don't need to wait other processes, let's stop the main
            if ps -p $MAINPID &> /dev/null; then
                log " - terminating the main <$MAINPID>"
                kill -TERM $MAINPID &> /dev/null
            fi
        fi
    fi
    # To prevent invoking error trap from error trap ;)
    # The correct exit code was taken before diving into this function
    return 0
}

infinite_loop() {
    log "Activated infinite loop! To stop, press <Ctrl+C> or send SIGTERM..."
    while true; do
        sleep 60
    done
}

ns_long() {
    local _ns

    case "$1" in
        fg|sync)  _ns="foreground";;
        bg|async) _ns="background";;
        sd|halt)  _ns="shutdown";;
        main)     _ns="boot";;
         *)       _ns="$1";;
    esac

    echo "$_ns"
}

main "$@"
