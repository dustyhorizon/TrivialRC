#!/bin/bash

# TrivialRC - The minimalistic RC system and process manager for containers
# Copyright (c) 2016,2017 by Oleksii Tsvietnov, me@vorakl.name
# Version: 1.1.0

# --[ Environment variables ]--
# RC_DEBUG (true|false) [false]
#    Prints out all commands which are being executed
# RC_VERBOSE (true|false) [false]
#    Prints out service information
# RC_VERBOSE_EXTRA (true|false) [false]
#    Prints out additional service information
# RC_WAIT_POLICY (wait_all|wait_any|wait_forever) [wait_any]
#    - wait_all      quit after exiting the last command (back- or foreground)
#    - wait_any      quit after exiting any of command (including zero commands)
#    - wait_forever  will be waiting forever after exiting all commands.
#                    Usefull in case of daemons which are detaching and exiting

set +e # Do not exit on errors by default
if [[ "${RC_DEBUG}" = "true" ]]; then
    set -x # Turns on Debug mode if true
fi
: ${RC_WAIT_POLICY:=wait_any} # Sets default value for a wait policy

main() {
    trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_main_exit; exit ${_exitcode}' EXIT
    trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
    trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

    export SELF_NAME=$(basename $0 .sh) # Self name for logging purpose
    export DIR_NAME=$(dirname $0)
    export MAINPID="${BASHPID}" # PID of the main process
    export EXIT_FLAG="/tmp/trc.${MAINPID}.exiting"
    childpid="" # Collecting child processes
    ns="main" # Name Space
    local _wait_bg_cmd _file _exitcode=0 _exitcode2=0

    # Checks if there is an exit flag on startup
    if [[ -n "${EXIT_FLAG}" ]] && [[ -f ${EXIT_FLAG} ]]; then
        err "An exit flag ${EXIT_FLAG} exists! Exiting..."
    fi

    case "${RC_WAIT_POLICY}" in
        wait_all)  _wait_bg_cmd="command -p wait";;
        wait_any)  _wait_bg_cmd="command -p wait";;
        *)         _wait_bg_cmd=":";;
    esac

    log "The wait policy: ${RC_WAIT_POLICY}"


    # Reads commands from files to run before everything
    for _file in $(ls ${DIR_NAME}/trc.boot.* ${DIR_NAME}/trc.d/boot.* 2>/dev/null || true); do
        set -e

        log "Launching on the $(ns_long ${ns}): ${_file}"
        . ${_file}

        set +e
    done

    # Checks for boot tasks in the command line
    while [[ "$1" = "-B" ]]; do
        shift
        set -e

        log "Launching on the $(ns_long ${ns}): $1"
        eval "$1"

        set +e
        shift
    done

    # Reads commands from files to run on the background (in parallel)
    for _file in $(ls ${DIR_NAME}/trc.bg.* ${DIR_NAME}/trc.async.* ${DIR_NAME}/trc.d/async.* 2>/dev/null || true); do
         {
          (
            set -e
            # Run this on any exit, catching the exitcode of the "main" command,
            # printing additional info and finishing up this sub-program with the right exitcode
            trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "${_file}"; exit ${_exitcode}' EXIT

            # In case of exit on errors (set -e) or by a signal, catch exitcode and exit with it, which
            # will lead to triggering an EXIT trap
            trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

            ns="async"
            log "Launching on the $(ns_long ${ns}): ${_file}"
            . ${_file}
          )& 
         } 2> /dev/null

        childpid="${childpid} $!"
    done

    # Checks for background tasks in the command line
    while [[ "$1" = "-D" ]]; do
        shift
        { # supressing stderr for avoiding uncontrolled messages like "Terminated" or "Killed"
          (
            set -e
            trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "$1"; exit ${_exitcode}' EXIT
            trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

            ns="async"
            log "Launching on the $(ns_long ${ns}): $1"
            eval "$1"
          )& 
        } 2> /dev/null
        childpid="${childpid} $!"
        shift
    done

   # Checks for foreground tasks in files (sequentially)
    for _file in $(ls ${DIR_NAME}/trc.fg.* ${DIR_NAME}/trc.sync.* ${DIR_NAME}/trc.d/sync.* 2>/dev/null || true); do
        (
            set -e
            trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "${_file}"; exit ${_exitcode}' EXIT
            trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

            ns="sync"
            log "Launching on the $(ns_long ${ns}): ${_file}"
            . ${_file}
        )
        # Catch the exitcode of a foreground sub-program
        _exitcode=$?
    done

    # Checks for foreground tasks in the command line
    while [[ "$1" = "-F" ]]; do
        shift
        (
            set -e
            trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "$1"; exit ${_exitcode}' EXIT
            trap '_exitcode=$?; debug "sig-trap (exitcode=${_exitcode})"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap (exitcode=${_exitcode})"; exit ${_exitcode}' ERR

            ns="sync"
            log "Launching on the $(ns_long ${ns}): $1"
            eval "$1"
        )
        shift
        _exitcode=$?
    done

     # Checks for a foreground task in the command line (one parameter with all commands)
    if [[ -n "$*" ]]; then
        (
            set -e
            trap '_exitcode=$?; debug "exit-trap (exitcode=${_exitcode})"; hook_sub_exit ${_exitcode} "$@"; exit ${_exitcode}' EXIT
            trap '_exitcode=$?; debug "sig-trap (exitcode=$_exitcode)"; exit ${_exitcode}' HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS
            trap '_exitcode=$?; debug "err-trap (exitcode=$_exitcode)"; exit ${_exitcode}' ERR

            ns="sync"
            log "Launching on the $(ns_long ${ns}): $@"
            "$@"
        )
        # Catch the exitcode of a foreground sub-program
        _exitcode=$?
    fi

    # Wait for all background processes and exit with a status of the last one
    # or with 128+SIGNAL in case of getting a signal
    ${_wait_bg_cmd} ${childpid}
    _exitcode2=$?

    if [ ${_exitcode2} -ne 0 ]; then
        _exitcode=${_exitcode2} # update exit code only if one of background processes has failed
    fi

    if [[ "${RC_WAIT_POLICY}" = "wait_forever" ]]; then
        infinite_loop
    fi

    return ${_exitcode}
}

say() {
    if [[ "${RC_VERBOSE}" = "true" ]]; then
        echo "$@"
    fi
}

log() {
    say "$(date '+%Y-%m-%d %H:%M:%S') ${SELF_NAME} [${ns}/${BASHPID}]: $@"
}

warn() {
    log "$@" >&2
}

err() {
    warn "$@"
    exit 1
}

debug() {
    if [[ "${RC_VERBOSE_EXTRA}" = "true" ]]; then
        log " - $@"
    fi
}

hook_main_exit() {
    set +e # do not stop or errors anyway

    # Checks if there is an exit flag on exit
    if [[ -n "${EXIT_FLAG}" ]] && [[ -f ${EXIT_FLAG} ]]; then
        warn "An exit flag ${EXIT_FLAG} exists! I'm already exiting..."
        return 0
    fi

    # Creating an exit flag
    touch ${EXIT_FLAG} || warn "Cannot create ${EXIT_FLAG}"

    local _pid _file _term_timeout=5

    log "Going down. Running shutdown scripts..."
    # Checks for shutdown tasks in files (sequentially)
    for _file in $(ls ${DIR_NAME}/trc.sd.* ${DIR_NAME}/trc.halt.* ${DIR_NAME}/trc.d/halt.* 2>/dev/null || true); do
        (
            ns="halt"
            set -e # Exit on errors in the sub-shell
            log "Running the shutdown script: ${_file}"
            . ${_file}
        )
    done

    log "Handling of termination..."
    for _pid in ${childpid}; do
        if ps -p ${_pid} &> /dev/null; then
            debug "terminating the child process <pid=${_pid}>"

            # Removes all unexpected sub-processes
            pkill -TERM -P ${_pid} &> /dev/null           
            kill -TERM ${_pid} &> /dev/null

            while ps -p ${_pid} &>/dev/null && [[ ${_term_timeout} -gt 0 ]]
            do
                sleep 1
                : $((_term_timeout--))
            done

            if  ps -p ${_pid} &>/dev/null; then
                pkill -KILL -P ${_pid} &> /dev/null
                kill -KILL ${_pid} &> /dev/null
            fi
        fi
    done
    # Removes all unexpected sub-processes
    pkill -KILL -P ${MAINPID} &> /dev/null

    if [[ -n "${EXIT_FLAG}" ]] && [[ -f ${EXIT_FLAG} ]]; then
        rm -f ${EXIT_FLAG} || warn "Cannot remove ${EXIT_FLAG}"
    fi

    log "Exited."

    # It's not needed to exit with a proper exit code here.
    # The programm will exit with correct exit code from EXIT trap of main()
}

hook_sub_exit() {
    set +e # do not stop or errors anyway

    local _rc=$1 # Getting the exit code for a logging purpose only
    shift

    log "Exiting on the $(ns_long ${ns}) (exitcode=${_rc}): $@"

    if [[ "${RC_WAIT_POLICY}" = "wait_any" ]]; then 
        if [[ -n "${EXIT_FLAG}" ]] && [[ ! -f ${EXIT_FLAG} ]]; then
            # If exiting from a bg process and don't need to wait other processes, let's stop the main
            if ps -p ${MAINPID} &> /dev/null; then
                debug "terminating the main process <pid=${MAINPID}>"
                kill -TERM ${MAINPID} &> /dev/null
            fi
        fi
    fi
    # To prevent invoking error trap from error trap ;)
    # The correct exit code was taken before diving into this function
    return 0
}

infinite_loop() {
    log "Activated infinite loop! To stop, press <Ctrl+C> or send SIGTERM..."
    while true; do
        sleep 60
    done
}

ns_long() {
    local _ns

    case "$1" in
        fg|sync)  _ns="foreground";;
        bg|async) _ns="background";;
        sd|halt)  _ns="shutdown";;
        main)     _ns="boot";;
         *)       _ns="$1";;
    esac

    echo "${_ns}"
}

main "$@"
